<div class="step-text">
<p>Sometimes you will come across classes in your projects that are specifically meant for storing data. For these, the layout is always the same: you have your variables, <a class="theory-lookup not-relevant" href="/learn/step/18329" rel="noopener noreferrer nofollow" target="_blank" title="In Java, getters are methods used to retrieve and return the value of a field in a class. | They are used to protect and hide the data by providing controlled access to the private fields within a class. Getters are important for data encapsulation, which is the practice of wrapping data and methods that manipulate that data within a single unit, typically a class. This allows for increased security and control over the data, a well-organized code structure, and reduced risk of data corruption. Getters usually contain minimal programming logic and may return non-stored values calculated at runtime.">getters</a>, and a constructor that takes all the information to create the object, and, in most cases, you will also want to override the <code class="language-java">toString()</code>, <code class="language-java">equals()</code>, and <code class="language-java">hashCode()</code> methods. This is where <strong>Records</strong> come to your rescue.</p><h5 id="records">Records</h5><p>A <strong>record</strong>, like classes, is a way to <a class="theory-lookup not-relevant" href="/learn/step/18329" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a declaration is a statement that introduces a variable, method, or class into the program. | It specifies the type of the entity being declared, its name, and other relevant information such as access modifier, return type (for method), and initial value (for variable). For example, the declaration of a method may include its name, return type, access modifier, and parameter list. Declarations are essential for Java to understand the structure and behavior of the program. Incorrect declarations can lead to compilation errors. In the context of variables, a declaration specifies the type, name, and initial value of a variable. The type of a variable determines what possible operations can be performed on the variable and which value can be stored in it. Every variable has a name (also known as an identifier) to distinguish it from others. Before using a variable, it must be declared. The general form of a variable declaration is: `type identifier = value;`

It's important to note that a declaration is not the same as an assignment.">declare</a> a new type in Java. Now you may wonder why we need records when we already have classes to do the same job. The answer is boilerplate code or, more precisely, boilerplate reduction. The biggest difference from something like Lombok is that Records have language-level support, which means you don't need any third-party dependencies, so they are more attractive to use. They basically are value objects out of the box as they are immutable: their state cannot be modified once created.</p><h5 id="defining-records">Defining records</h5><p>A new Java Record is declared with the <code class="language-java">record</code> keyword followed by the name of the record and ending with parentheses. Let's create an empty record named <code class="language-java">User</code> for now. It would look like this:</p><pre><code class="language-java">record User() {
    // empty body
}</code></pre><p>Ok, now we have created our first record, but it's not exactly useful just yet. Let's give the User a username and a password. We'll do that by writing the variables inside the parentheses:</p><pre><code class="language-java">record User(String username, String password) {
    // empty body
}</code></pre><p>Now our <code class="language-java">User</code> record has a username and a password variable, but where are the getters and the constructor? Those are automatically generated by the Java Compiler.</p><p>Now let's look at the <code class="language-java">class</code> implementation of this code:</p><pre><code class="language-java">public final class User {

    private final String username;
    private final String password;

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String username() {
        return username;
    }

    public String password() {
        return password;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this)
            return true;
        if (obj == null || obj.getClass() != this.getClass())
            return false;
        var that = (User) obj;
        return Objects.equals(this.username, that.username) &amp;&amp;
                Objects.equals(this.password, that.password);
    }

    @Override
    public int hashCode() {
        return Objects.hash(username, password);
    }

    @Override
    public String toString() {
        return "User[" +
                "username=" + username + ", " +
                "password=" + password + ']';
    }


}</code></pre><p>Here we can see the advantages of records: they reduce the need to write boilerplate code by a lot.</p><h5 id="custom-constructors">Custom constructors</h5><p>While a constructor is automatically generated for us, we can still customize its implementation:</p><pre><code class="language-java">public record User(String username, String password) {
    public User {
        if (username == null || password == null) {
            throw new IllegalArgumentException("Username and password must not be null");
        }
    }
}</code></pre><p>Notice the way the constructor is written. Unlike a class constructor, a record constructor doesn't have a formal parameter list: instead, it's just the access modifier followed by the name of the record and ending with curly brackets. This constructor type is called a <strong>compact constructor.</strong></p><h5 id="custom-getters">Custom getters</h5><p>Getters in records are named after the variable they give back. In our example above, the getter name of <code class="language-java">username</code> would be <code class="language-java">username()</code>. Now we can customize these getters by simply repeating the same method signature and inserting our code in curly brackets:</p><pre><code class="language-java">public record User(String username, String password) {

  public String username() {
    return username.toUpperCase(Locale.ENGLISH);
  }
}</code></pre><h5 id="record-patterns">Record Patterns</h5><p>Java 21 introduced <strong>Record Patterns</strong>, a powerful enhancement that allows you to deconstruct record values directly in pattern matching. Record patterns can extract values from a record in a destructuring-like syntax. It works seamlessly with <code class="language-java">instanceof</code>:</p><pre><code class="language-java">Object obj = new User("alice", "secret");

if (obj instanceof User(String username, String password)) {
    System.out.println("Username: " + username);
    System.out.println("Password: " + password);
}</code></pre><p>Records also work seamlessly with <code class="language-java">switch</code>: </p><pre><code class="language-java">static void printUser(Object obj) {
    switch (obj) {
        case User(String username, String password) -&gt; 
            System.out.println("User: " + username);
        default -&gt; 
            System.out.println("Not a User");
    }
}</code></pre><p>This seamless integration allows both type checking and data extraction in a single step. On top of this, record patterns also support nesting, allowing you to deconstruct deeply structured data in a single line.</p><pre><code class="language-java">record Name(String first, String last) {}
record User(Name name, String password) {}

Object obj = new User(new Name("Alice", "Smith"), "secret");

if (obj instanceof User(Name(String first, String last), String password)) {
    System.out.println("First name: " + first);
    System.out.println("Last name: " + last);
}</code></pre><p>This is especially useful in applications like parsing JSON, handling ASTs, or navigating domain models, where you often deal with nested data.</p><h5 id="features-and-limitations">Features and limitations</h5><p>So what are the limitations of records? First of all, they can't extend a class. However, you can still declare them inside another class. They are also implicitly final, which means they can't be abstract and also can't be extended by any other class, but you can still implement interfaces with them. The next restriction is that you can't declare instance fields except for the ones in the record signature, which are also immutable, so once they are created you can't change the values of a record. They can still be generic and have static components (methods, fields, and initializers) as well as constructors and <a class="theory-lookup not-relevant" href="/learn/step/18329" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an instance method is a method that belongs to each object created of a particular class. | It can access fields of the specific object of the class. For example, if we have a class with two instance methods: method1() and method2(), and two objects: object1 and object2, the output of these methods will be different for each object because they have different values for the fields. To use an instance method, you must first create an object.">instance methods</a>. They are also compatible with annotations.</p><p>Let's sum this up again. Records <strong>cannot</strong>:</p><ul><li><p>be abstract;</p></li><li><p>extend classes;</p></li><li><p>declare <a class="theory-lookup not-relevant" href="/learn/step/18329" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an instance field is a field declared with the keyword instance variable that is associated with an object (instance) of a class, rather than the class itself. | It can hold any primitive or reference type, and each object of the class has its own unique instance field value, which can be different from other objects of the same class. Instance fields can be accessed within the class using the this keyword. They are often used to store and manipulate the state of an object, and provide more functionality compared to static fields.">instance fields</a>;</p></li><li><p>be extended by classes.</p></li></ul><p>On the other hand, records <strong>can</strong>:</p><ul><li><p>be declared inside a class;</p></li><li><p>implement interfaces;</p></li><li><p>be generic;</p></li><li><p>be compatible with annotations;</p></li><li><p>have static components;</p></li><li><p>have constructors;</p></li><li><p>have instance methods.</p></li></ul><h5 id="conclusion">Conclusion</h5><p>Records are a new way to declare a type in Java, similar to classes. Using records, we can reduce the boilerplate code of immutable data classes as most of the code is generated by the compiler. They are supported on the language level and therefore don't need any third-party dependencies to work.</p>
</div>